# NDC 2012 Note

## Lockless(잠금 없는) 게임 서버 구현

##### Speaker: 김성익 (소프트네트)

* 스피커는 게임 엔진을 개발하다 서버 개발로 전향함.
* 인피니티 온라인의 로비서버는 IOCP 서버 모델.
* 게임 서버는 UDP만 사용.

### 싱글 스레드 서버
* 코드#1은 단순하게 짰는데, 멀티 스레드로 넘어가니까 데이터 무결성이 문제.
* 그래서 코드#2는 크리티컬 섹션을 추가.
	* 중복 실행은 안됨. - 무결성 보장
	* 그러나 동기화를 잘못하면,
		- 바로 다운되는 경우는 운이 좋은 거고,
		- 보통은 잘못된 값이 복사되어 퍼지고,
		- 결과를 예측하기 어려워짐.
		- 최악의 경우엔 데드락.
* 동기화 정책은 안정성과 성능을 모두 요구하기에 개발 퍼포먼스가 저하, 프로그래머들에게 스트레스로…
* 싱글 스레드 게임 서버 모델은 단순하지만 확장성이 낮아 여러 한계점이 있음. 당연한가…
* 코드가 비직관적, 기계적인 코드 작업/예외 처리… 장점도 있는데 잠금처리가 필요 없으니 원자성, 격리성이 보장되고 안정적이고 결과 예측이 가능하다고.

### 직렬화 서버
* 싱글 스레드 게임 서버 모델을 멀티 스레드에 가져오는 것을 시도함.
* 이걸 한 마디로 하면 "직렬화".
	* 여기서 사용하는 "직렬화"는 일반적인 serialization과는 다른 의미라고.
* 직렬화 모델은 멀티 스레드 모델과 달리 요청들을 정해진 기준에 따라 특정 스레드에 몰아주는 것. 1번방 처리는 1번째 스레드에, 이런 식.
* 이 모델의 장점
	* 싱글 스레드 모델처럼 잠금이 불필요하고,
	* 동시에 멀티 스레드의 장점인 성능, 확장성을 얻을 수 있음.
* 이 모델을 구현하면, 스레드별로 IOCP가 생성되고, 소켓은 필요한 곳의 IOCP에만 등록.
* 이 모델의 문제점은
	* 소켓의 재사용이 불가능,
	* 연결 중 방 이동이 불가능.
	* 그래서 PostQueuedCompletionStatus 함수를 만듬(…
		* 이 함수(PQCS)는 Demultiplexer 역할을 함. GQCS가 어디서 실행됐는지 알아낸 후 스레드에 던져줌(?).
* 그래서 개발중인 서버는 이를 극복할 방법을 적용한다고.

#### IO 이슈
* 핵심은 동기 함수 대 비동기 함수 간 IO 처리 방식의 문제.
* 게임서버에서 디비 쿼리를 날리는 것을 스레드 내에서? 바로 처리하면 단순, 직관적.
* 그래서 세운 패킷 처리 정책이 패킷 구분하기와 패킷 타입/스레드 할당이 다르면 분기. 게임 업데이트를 스레드 내에서 처리한다던가, 클라이언트와 유사한 씬(scene?) 처리를 한다던가…

#### 도전과제
* Many Integrated Core, 로드 밸런싱. MIC는 인텔이 시도한 것의 유사한 개념.
	* 다수의 요청을 한 번에 처리해야하는 게임 서버의 특성상 스레드가 많으면 많을수록 좋…을까? 로드 밸런싱이 받쳐줘야 하는데, 개인적으론 가상 서버에서 힌트를 얻을 수 있지 않을까.

### 결론
* 잠금 없는 서버는 개발 퍼포먼스, 안정성을 올리고 복잡도를 낮추고 직관적 코드 관리가 가능해진다.