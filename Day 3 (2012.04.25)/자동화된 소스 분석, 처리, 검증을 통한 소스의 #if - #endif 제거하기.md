# NDC 2012 Note

## 자동화된 소스 분석, 처리, 검증을 통한 소스의 #if와 #endif 없애기

##### Speaker: 김이선 (넥슨 신규개발본부)

* 프로젝트 소스코드의 유지보수성 관리가 중요! 코드를 늘 깔끔하게.
* 던파에서 했던 코드 관리 중 하나인 불필요한 #if와 #endif 제거

### 도입
* 오늘 알아볼 코드는 던파. 이해를 위해 변형.
* 퀘스트 시스템 추가 작업한다고 가정.
	* 플래그 정의. #define …
	* 코드 작성. #ifdef … #else … #endif
	* 기능 플래그 켬.
* 장점
	- 작업중인 코드가 다른 작업자, 라이브 코드에 영향을 주지 않음. (장기간 작업, 빠르고 편리한 코드 롤백, 이벤트.)
	- 국가별 소스코드 공유에 도움 (국가별 플래그, …)
	- 간단한 작업 방식 (교육 비용이 낮음)
* 단점
	- 플래그 켬/끔 하면 리빌드 필요
	- 코드 난독화: 읽기 어려워짐
	- 죽은 코드: 공간만 차지.	
	- 중복 코드
* 이대로 개발이 계속되면 플래그 갯수는 기하급수적으로 증가.
* 그래서 플래그 작업 방식은 유지하되, 불필요하게 늘어난 플래그 개수를 줄여보자.
	* 플래그 켜서 제거 - 정착한 콘텐츠를 중심으로.
	* 플래그 꺼서 제거 - 안 쓰는 콘텐츠 제거.
	* 플래그 병합 제거 - 중첩 선언되는 플래그는 상위 플래그로 통합.
* 그런데 수천 개의 플래그를 수작업으로?
* 리팩토링 딜레마! 실수하면? 누가하지?
* 그래서 자동화.

### 분석
* 플래그에 대한 정보 얻기.
	* 검색
	* 국가별
	* 주석도 가져오기
	* SCM 로그
* 단순한 정보 나열을 구체화.
	* 디비 사용 - 유연한 분석 가능
	* 국가별/연도별 플래그 등장 표
	* 시간별 증감 추이, 국가별 사용 현황, 작업자별 플래그 추가, 파일별 플래그 추이, 플래그 영향력, …
	* 오류 분석
		- 버려진 플래그 찾기
		- 정의 안 되고 사용하는 플래그 찾기
		- 중복 정의됨
		- 중복 정의되고 값이 다름
	* 모두 켜거나 끈 플래그 목록 추리기
		- 작성자 및 상급자에게 리뷰 요청 -> 피드백 받은 후 진행

### 처리
* 툴 써서 (unifdef - [http://dotat.at/prog/unifdef/](http://dotat.at/prog/unifdef/) )
	- 기본적인 건 잘 해주는데, 부분 평가는 안 해줌.
	- 병합 제거는 따로 구현

### 검증
* 컴파일
	- 동일한 소스를 두 번 빌드 후 EXE - 디버그 정보 때문에…
	- 동일한 소스를 두 번 빌드 후 OBJ - 역시 다름
* 그래서, 원시 코드 컴파일 vs 결과 코드 컴파일 후 각 OBJ 비교.
	* 같음: OK
	* 다름
		- 다른 함수 찾기
		- 원인 파악
			- 매크로 켬/끔 오류
			- ㄹㄹㄹ
* 주의
	* \_\_LINE__ 유지
	* \_\_TIME__ 작업할 때만 유지.
* 리뷰
	* 한 번에 300~500개 씩 총 6번 작업.

### 결과
* 2,309 파일에서 191,979 라인 제거.
	* 리뷰할 필요도 없고 살릴 필요도 없는 죽은 코드를 제거.
	* 전체의 10% 정도. 존나좋군?
* 제거에 사용한 툴은 1500 라인 정도.

### 결론
* 불필요한 #if #endif 제거는 소스코드 유지보수성 향상
* 유지보수성 확보 작업을 자동화, 신뢰성있게 만들어야.
	* 분석, 수행, 검증 프레임워크 구축
* 반복 사용 가능하기에 계속해서 도움을 받을 수 있음.
* 분석은 처리 뿐만 아니라 대상을 바라보는 다른 관점을 제시.
* 분석, 수행, 검증의 틀을 코드/데이터 개선에 사용해보자!
* 자동화된 Rename 리팩토링?
	* 문제되는 이름 추리기
	* 자동화된 분석, 결과 수집
	* 결과 분석 후 리팩토링 수행

### Q&A
* 신규 개발하는 게임에선? 플래그가 지원되지 않는다면? - 가능하면 동적으로 켤 수 있도록.
* 컴파일 시간에 처리하는 것 대 컴파일 후 처리? 비용의 문제